//This GNU Octave function provides an interface to load data
//from files created with the XB toolkit.
//The data must have been generated from the struct XB::XB::clusterZ.
//This means that translated data from experiment and simulation
//can be loaded with this interface.
//NOTE: there's no guarantee whatsoever that this function
//      would be at all usable with MATLAB in a MEX file.
//      It will *not* be tested and it is *not* ment as such.

//octave's documentation string
#define O_DOC_STRING "-*- texinfo -*-\n\
@deftypefn{Function File} {@var{XB::clusterZ_field} =} xb_load_klz_field( @var{filename} )\n\
@deftypefnx{Function File} {@var{XB::clusterZ_field} =} xb_load_klz_field( @var{file_1}, @var{file_2}, ... )\n\
@deftypefnx{Function File} {@var{XB::clusterZ_field} =} xb_load_klz_field( @var{file_1}, ..., @var{nb_events} )\n\
@deftypefnx{Function File} {@var{XB::clusterZ_field} =} xb_load_klz_field( @var{file_1}, ..., [@var{from_event}, @var{to_event}] )\n\
Loads an array of XB::XB::clusterZ from a file generated by the program \"xb_run_cluster\".\n\
\n\
If one of the @var{file_n} does not exist, a warning message is printed and the file is ignored.\n\
\n\
The format of @var{XB::clusterZ_field} is just an octave array:\n\
\n\
For more information about the content of the fields, use the documentation of the toolkit.\n\
@end deftypefn"

//stl includes
#include <vector>
#include <string>
#include <string.h> //strstr

//includes from octave
#include <octave/oct.h> //all the gobbins for OCT files
#include <octave/Array.h> //octave arrays arrays
#include <octave/file-stat.h> //file_stat

//includes from the toolkit
#include "xb_io.h" //XB::load
#include "xb_cluster.h" //XB::cluster, XB::XB::clusterZ
#include "xb_error.h" //XB::error

//------------------------------------------------------------------------------------
//an enum for the fields
typedef enum klz_field_type {
	NONE = '@',
	STR_N, //wide characeter capital A
	STR_EVNT, //and subsequent in alphabetcal order
	STR_IN_BETA,
	KLZ_N,
	KLZ_CENTROID_ID,
	KLZ_C_ALTITUDE,
	KLZ_C_AZIMUTH,
	KLZ_SUM_E,
	KLZ_CRYS_E,
	KLZ_CRYS
} klz_field_t;

//------------------------------------------------------------------------------------
//helper functions:
klz_field_t string2field_t( const std::string &field ); //retrieves a field type from a field name

//extractors for the fields
Array<octave_uint32> get_str_n( std::vector<XB::clusterZ> &data );
Array<octave_uint32> get_str_evnt( std::vector<XB::clusterZ> &data );
Array<float> get_str_in_beta( std::vector<XB::clusterZ> &data );
Array<octave_uint32> get_klz_n( std::vector<XB::clusterZ> &data );
Array<octave_uint32> get_klz_centroid_id( std::vector<XB::clusterZ> &data );
Array<float> get_klz_c_altitude( std::vector<XB::clusterZ> &data );
Array<float> get_klz_c_azimuth( std::vector<XB::clusterZ> &data );
Array<float> get_klz_sum_e( std::vector<XB::clusterZ> &data );
Array<float> get_klz_crys_e( std::vector<XB::clusterZ> &data );
Array<octave_uint32> get_klz_crys( std::vector<XB::clusterZ> &data );

//------------------------------------------------------------------------------------
//the interface
//char doc_str[] = O_DOC_STRING;
DEFUN_DLD( xb_load_klz_field, args, nargout, O_DOC_STRING ){
	//argument checks: they must be one or more strings
	int nargin = args.length();
	unsigned int load_nb_events[2] = { 0, 0 };
	klz_field_t target_field = KLZ_SUM_E;
	
	//chek on the numerical types
	if( sizeof(octave_uint32) != sizeof(unsigned int) ){
		error( "Quirky types." );
	}
	
	if( nargin == 0 ){
		error( "At least one file name must be provided" );
	}
	
	//loop-load the files and get the number of events to load
	std::vector<XB::clusterZ> data, data_buf;
	char in_fname[256];
	for( int f=0; f < nargin; ++f ){
		if( args(f).is_string() ){ //if the argument is a string
		                           //can be either a file or a field
		  if( args(f).string_value() == "field" ){
		  	if( nargin <= f+1 ) error( "xb_load_klz_field: field requested and no field given." );
		  	target_field = string2field_t( args(f+1).string_value() );
		  	if( target_field == NONE ) return octave_value_list();
		  	++f; //move up one before the loop ends
		  	continue; //that was it.
		  }
		  
			octave::sys::file_stat fs( args(f).string_value() );
			if( fs.exists() ){
				strcpy( in_fname, args(f).string_value().c_str() );
				try{
					XB::load( in_fname, data_buf );
				} catch( XB::error e ){
					error( e.what() );
				}
				data.insert( data.end(), data_buf.begin(), data_buf.end() );
				data_buf.clear();
			} else {
				octave_stdout << "xb_load_klz_field: warning: file \""
				              << args(f).string_value() << "\" doesn't exist.\n";
				continue;
			}
		} else if( args(f).is_scalar_type() && args(f).is_numeric_type() ){ //just load some events

			load_nb_events[1] = args(f).int_value();
		} else if( !args(f).is_scalar_type() && args(f).is_numeric_type() ){ //load a range of events
			load_nb_events[0] = args(f).int32_array_value()(0);
			load_nb_events[1] = args(f).int32_array_value()(1);
		} else {
			octave_stdout << "xb_load_klz_field: warning: argument "
			              << f << " is not vaild.\n";
			continue;
		}
	}

	//consistency check on the range: if the range is zero
	//or if it's backward, load everything, silently.
	if( load_nb_events[1] <= load_nb_events[0] ){
		load_nb_events[0] = 0;
		load_nb_events[1] = 0;
		--load_nb_events[1];
	}

	//check that something has been read
	if( !data.size() ){
		octave_stdout << "xb_load_XB::clusterZ: warning: no data loaded.\n";
		return octave_value_list();
	}

	//now crop the data accordin to the load_nb_event[] thingie
	std::vector<XB::clusterZ>::iterator data_set_begin = data.begin();
	std::vector<XB::clusterZ>::iterator data_set_end = data.end();
	if( load_nb_events[1] > load_nb_events[0] ){ //then do cropping
		data_set_begin += load_nb_events[0];
		data_set_end = data.begin() + load_nb_events[1];
		if( data_set_begin > data.begin() ) data.erase( data.begin(), data_set_begin );
		if( data_set_end < data.end() ) data.erase( data_set_end, data.end() );
	}

	//and now, switch on the
	octave_value o_field;
	switch( target_field ){
		case STR_N : //the multiplicity
			o_field = get_str_n( data );
			break;
		case STR_EVNT : //the event number (no idea why...)
			o_field = get_str_evnt( data );
			break;
		case STR_IN_BETA : //the incoming beta of the events
			o_field = get_str_in_beta( data );
			break;
		case KLZ_CENTROID_ID : //the index of the cluster's centroid
			o_field = get_klz_centroid_id( data );
			break;
		case KLZ_C_ALTITUDE : //altitude (see doc) of the centroid
			o_field = get_klz_c_altitude( data );
			break;
		case KLZ_C_AZIMUTH : //the azimuth thereof (see doc)
			o_field = get_klz_c_azimuth( data );
			break;
		case KLZ_SUM_E : //the sum energy of the cluster
			o_field = get_klz_sum_e( data );
			break;
		case KLZ_CRYS_E : //single energy deposits in the crystals
			o_field = get_klz_crys_e( data );
			break;
		case KLZ_CRYS : //the indexes of the activated crystals
			o_field = get_klz_crys( data );
			break;
		case NONE : default :
			return octave_value_list();
	}
	//NOTE: why not returning directly every case?
	//      because we may want to do something else with the
	//      o_field content before returning it, at some point.
	
	//very important cleanup
	data.clear();
	
	//happy thoughs
	return o_field;
}


//------------------------------------------------------------------------------------
//helper function section:

//------------------------------------------------------------------------------------
//the string to field type parser
klz_field_t string2field_t( const std::string &field ){
	char field_name[64];
	strcpy( field_name, field.c_str() );
	
	if( strstr( field_name, "n" ) ) return STR_N;
	if( strstr( field_name, "evnt" ) ) return STR_EVNT;
	if( strstr( field_name, "in_beta" ) ) return STR_IN_BETA;
	if( strstr( field_name, "clusters.centroid_id" ) ) return KLZ_CENTROID_ID;
	if( strstr( field_name, "clusters.c_altitude" ) ) return KLZ_C_ALTITUDE;
	if( strstr( field_name, "clusters.c_azimuth" ) ) return KLZ_C_AZIMUTH;
	if( strstr( field_name, "clusters.sum_e" ) ) return KLZ_SUM_E;
	if( strstr( field_name, "clusters.crys_e" ) ) return KLZ_CRYS_E;
	if( strstr( field_name, "clusters.crys" ) ) return KLZ_CRYS;
	
	return NONE; //on failure to find a valid field name.
}

//------------------------------------------------------------------------------------
//extract the multiplicities
Array<octave_uint32> get_str_n( std::vector<XB::clusterZ> &data ){
	dim_vector o_dim_v( data.size(), 1 );
	Array<octave_uint32> o_field( o_dim_v );
	
	//loop on the clusters
	for( int i=0; i < data.size(); ++i ) o_field(i) = data[i].n;
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the event numbers
Array<octave_uint32> get_str_evnt( std::vector<XB::clusterZ> &data ){
	dim_vector o_dim_v( data.size(), 1 );
	Array<octave_uint32> o_field( o_dim_v );
	
	//loop on the clusters
	for( int i=0; i < data.size(); ++i ) o_field(i) = data[i].evnt;
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the in_betas of the events
Array<float> get_str_in_beta( std::vector<XB::clusterZ> &data ){
	dim_vector o_dim_v( data.size(), 1 );
	Array<float> o_field( o_dim_v );
	
	//loop on the clusters
	for( int i=0; i < data.size(); ++i ) o_field(i) = data[i].in_beta;
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the clusters' dimensions
Array<octave_uint32> get_klz_n( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;
	
	//find the full length
	for( int i=0; i < data.size(); ++i ) sz += data[i].n;
	
	dim_vector o_dim_v( sz, 1 );
	Array<octave_uint32> o_field( o_dim_v );
	
	unsigned int glob_i = 0;
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			o_field(glob_i) = data[i].clusters[k].n;
			++glob_i;
		}
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the centroid id
Array<octave_uint32> get_klz_centroid_id( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;
	
	//find the full length
	for( int i=0; i < data.size(); ++i ) sz += data[i].n;
	
	dim_vector o_dim_v( sz, 1 );
	Array<octave_uint32> o_field( o_dim_v );
	
	unsigned int glob_i = 0;
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			o_field(glob_i) = data[i].clusters[k].centroid_id;
			++glob_i;
		}
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the centroid's altitude
Array<float> get_klz_c_altitude( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;
	
	//find the full length
	for( int i=0; i < data.size(); ++i ) sz += data[i].n;
	
	dim_vector o_dim_v( sz, 1 );
	Array<float> o_field( o_dim_v );
	
	unsigned int glob_i = 0;
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			o_field(glob_i) = data[i].clusters[k].c_altitude;
			++glob_i;
		}
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the centroid's azimuth
Array<float> get_klz_c_azimuth( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;

	//find the full length
	for( int i=0; i < data.size(); ++i ) sz += data[i].n;

	dim_vector o_dim_v( sz, 1 );
	Array<float> o_field( o_dim_v );

	unsigned int glob_i = 0;
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			o_field(glob_i) = data[i].clusters[k].c_azimuth;
			++glob_i;
		}

	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the total energy of the clusters
Array<float> get_klz_sum_e( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;
	
	//find the full length
	for( int i=0; i < data.size(); ++i ) sz += data[i].n;
	
	dim_vector o_dim_v( sz, 1 );
	Array<float> o_field( o_dim_v );
	
	unsigned int glob_i = 0;
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			o_field(glob_i) = data[i].clusters[k].sum_e;
			++glob_i;
		}
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retrieve the single crystal energy deposits
//NOTE: they are linearized
Array<float> get_klz_crys_e( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;
	
	//find the full length
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ) sz += data[i].clusters[k].n;
	
	dim_vector o_dim_v( sz, 1 );
	Array<float> o_field( o_dim_v );
	
	unsigned int glob_i=0; //this is the global index, referring to o_field
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			memcpy( o_field.fortran_vec() + glob_i,
			        &data[i].clusters[k].crys_e[0],
			        data[i].clusters[k].crys_e.size()*sizeof(float) );
			glob_i += data[i].clusters[k].crys_e.size();
		}			
	
	return o_field;
}

//------------------------------------------------------------------------------------
//retireve the single crystal indexes
//NOTE: linearized
Array<octave_uint32> get_klz_crys( std::vector<XB::clusterZ> &data ){
	unsigned int sz = 0;
	
	//find the full length
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ) sz += data[i].clusters[k].n;
	
	dim_vector o_dim_v( sz, 1 );
	Array<octave_uint32> o_field( o_dim_v );
	
	unsigned int glob_i=0; //this is the global index, referring to o_field
	for( int i=0; i < data.size(); ++i )
		for( int k=0; k < data[i].clusters.size(); ++k ){
			memcpy( o_field.fortran_vec() + glob_i,
			        &data[i].clusters[k].crys[0],
			        data[i].clusters[k].crys.size()*sizeof(unsigned int) );
			glob_i += data[i].clusters[k].crys.size();
		}			
	
	return o_field;
}
